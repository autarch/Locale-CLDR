#!/usr/bin/perl

use strict;
use warnings;

use 5.006;

use lib './lib', 'tools/lib';

use Data::Dumper;
use File::Copy qw( copy );
use File::Find::Rule;
use Getopt::Long;
use LDML;
use Lingua::EN::Inflect qw( PL_N );
use Locale::Country
    qw( country_code2code LOCALE_CODE_ALPHA_2 LOCALE_CODE_ALPHA_3 );
use LWP::Simple qw( get );
use Path::Class;

my $VERSION = '0.06';

my $ScriptName = file($0)->basename();

{
    no warnings 'once';
    $DateTime::Locale::InGenerator = 1;
}

my %opts = ( pod => 1 );

sub main {
    GetOptions(
        'dir:s'     => \$opts{dir},
        'file:s'    => \$opts{file},
        'version:s' => \$opts{version},
        'clean'     => \$opts{clean},
        'quiet'     => \$opts{quiet},
        'verbose'   => \$opts{verbose},
        'pod!'      => \$opts{pod},
        'help'      => \$opts{help},
    );

    $opts{help} = 1
        unless defined $opts{dir} && -d $opts{dir};

    usage() if $opts{help};

    require_version();

    clean() if $opts{clean};

    binmode STDOUT, ':utf8' if $opts{verbose};
    $| = 1;

    generate_from_cldr_xml();
}

sub usage {
    print <<'EOF';

This script parses the CLDR locale files and turns them into a set of
Perl modules.  It also generates the MANIFEST file.

It takes the following arguments:

  --dir      A directory containing CLDR XML files.  Required.

  --file     Parse just the file with the given name.  For debugging.

  --version  The CLDR version. Required when not debugging a single file.

  --clean    Remove old generated modules (which may not be valid with
             the latest CLDR data).

  --quiet    Don't display any output while processing files.

  --verbose  Spew lots of output while processing.

  --help     What you are reading

If the --file or --name options are specified, the MANIFEST will not
be generated.

EOF

    exit;
}

sub require_version {
    return if $opts{version};

    warn <<'EOF';

You must supply a CLDR version.

EOF

    exit;
}

sub clean {
    for my $f ( File::Find::Rule->file->name('*.pm')
        ->grep('This file is auto-generated')->in('lib') ) {
        unlink $f or die "Cannot unlink $f: $!";
    }
}

sub generate_from_cldr_xml {
    my @ldml = read_all_files();
    generate_pm_files(@ldml);
    generate_catalog(@ldml) unless $opts{file};
    if ( $opts{pod} ) {
        generate_pm_file_pod($_) for @ldml;
    }

    print "\nAll done\n" unless $opts{quiet};
}

sub read_all_files {
    my $dir = dir( $opts{dir} );

    my @ldml;
    while ( my $file = $dir->next() ) {
        next unless -f $file;
        next unless $file =~ /\.xml$/;
        next if $opts{file} && $opts{file} ne $file->basename();

        print "Reading $file\n" if $opts{verbose};

        my $ldml = LDML->new_from_file($file);

        # Any locale without this cannot be registered by
        # DateTime::Locale.
        next unless defined $ldml->en_language();

        push @ldml, $ldml;
    }

    return sort { $a->id() cmp $b->id() } @ldml;
}

sub generate_pm_files {
    my @ldml = @_;

    print "\nGenerating PM files\n" if $opts{verbose};

    for my $ldml ( sort @ldml ) {
        next if $ldml->alias_to();

        if ( $opts{verbose} ) {
            print sprintf(
                <<"EOF", $ldml->id(), ( join ' ', $ldml->parent_ids() ), $ldml->version(), $ldml->generation_date() );
  %s
    parent_ids:      %s
    version:         %s
    generation date: %s

EOF
        }

        generate_pm_file($ldml);
    }
}

sub generate_pm_file {
    my $ldml = shift;

    my $pm_file = file( qw( lib DateTime Locale ), $ldml->id() . q{.pm} );
    write_to_manifest($pm_file);

    open my $fh, '>:utf8', $pm_file
        or die "Cannot write to $pm_file: $!";

    write_pm_header( $fh, $ldml );
    write_pm_cldr_version($fh);
    write_pm_subs( $fh, $ldml );
    write_pm_footer( $fh, $ldml );
}

sub write_pm_header {
    my $fh   = shift;
    my $ldml = shift;

    my $source_file = $ldml->source_file()->basename();
    my $version     = $ldml->version();
    my $date        = $ldml->generation_date();
    my $id          = $ldml->id();

    print {$fh} <<"EOF" or die "print failed: $!";
###########################################################################
#
# This file is auto-generated by the Perl DateTime Suite locale
# generator ($VERSION).  This code generator comes with the
# DateTime::Locale distribution in the tools/ directory, and is called
# $ScriptName.
#
# This file as generated from the CLDR XML locale data.  See the
# LICENSE.cldr file included in this distribution for license details.
#
# This file was generated from the source file $source_file
# The source file version number was $version, generated on
# $date.
#
# Do not edit this file directly.
#
###########################################################################

package DateTime::Locale::$id;

use strict;
use warnings;
use utf8;

use base 'DateTime::Locale::Base';
EOF
}

sub write_pm_cldr_version {
    my $fh = shift;

    my $cldr_version = q{"} . quotemeta( $opts{version} ) . q{"};

    print {$fh} "sub cldr_version { return $cldr_version }\n\n";
}

sub write_pm_subs {
    my $fh   = shift;
    my $ldml = shift;

    foreach my $attr ( sort { $a->name() cmp $b->name() }
        LDML->meta()->get_all_attributes() ) {
        next
            unless $attr->name()
                =~ /^(?:day_|month_|quarter_|am_pm|era_|date_|time_|datetime_|first_day_)/;

        my $type = $attr->type_constraint();
        $type = $type->type_parameter()
            if $type->is_a_type_of('Maybe');

        if ( $type->is_a_type_of('ArrayRef') ) {
            write_arrayref_sub( $fh, $ldml, $attr->name() );
        }
        elsif ( $type->is_a_type_of('HashRef') ) {
            write_hashref_sub( $fh, $ldml, $attr->name() );
        }
        elsif ( $type->is_a_type_of('Str') ) {
            write_string_sub( $fh, $ldml, $attr->name() );
        }
        elsif ( $type->is_a_type_of('Int') ) {
            write_int_sub( $fh, $ldml, $attr->name() );
        }
        else {
            die "Cannot handle type: " . $type->name();
        }
    }

    write_hashref_sub( $fh, $ldml, 'merged_available_formats', '_available_formats' );

    for my $attr (qw( default_date_format_length default_time_format_length ))
    {
        my $def = $ldml->$attr();
        next unless defined $def;

        print {$fh} string_sub( q{_} . $attr,, $def );
    }

    write_field_names_sub( $fh, $ldml );
}

sub write_arrayref_sub {
    my $fh   = shift;
    my $ldml = shift;
    my $name = shift;

    my $arr = $ldml->$name();

    return unless @{$arr};

    print {$fh} arrayref_sub( $name, $arr );
}

sub arrayref_sub {
    my $name = shift;
    my $arr  = shift;

    my $val = join ', ', map { q{"} . quotemeta($_) . q{"} } @{$arr};

    return <<"EOF";
{
    my \$$name = [ $val ];
    sub $name { return \$$name }
}
EOF
}

sub write_hashref_sub {
    my $fh       = shift;
    my $ldml     = shift;
    my $name     = shift;
    my $sub_name = shift || $name;

    my $hash = $ldml->$name();

    return unless keys %{$hash};

    print {$fh} hashref_sub( $sub_name, $hash );
}

sub hashref_sub {
    my $name = shift;
    my $hash = shift;

    my $val = (
        join ",\n",
        map {
            q{          "}
                . quotemeta($_)
                . q{" => "}
                . quotemeta( $hash->{$_} ) . q{"}
            }
            sort keys %{$hash}
    );

    return <<"EOF";
{
    my \$$name =
        {
$val
        };
    sub $name { return \$$name }
}

EOF
}

sub write_string_sub {
    my $fh   = shift;
    my $ldml = shift;
    my $name = shift;

    my $str = $ldml->$name();

    return unless defined $str;

    print {$fh} string_sub( $name, $str );
}

sub string_sub {
    my $name = shift;
    my $str  = shift;

    my $val = quotemeta $str;

    return <<"EOF";
{
    my \$$name = "$val";
    sub $name { return \$$name }
}

EOF
}

sub write_int_sub {
    my $fh   = shift;
    my $ldml = shift;
    my $name = shift;

    my $int = $ldml->$name();

    return unless defined $int;

    print {$fh} int_sub( $name, $int );
}

sub int_sub {
    my $name = shift;
    my $int  = shift;

    return <<"EOF";
{
    my \$$name = $int;
    sub $name { return \$$name }
}

EOF
}

sub write_field_names_sub {
    my $fh   = shift;
    my $ldml = shift;

    my $val = qq[{\n];

    my $fields = $ldml->merged_field_names();

    for my $field ( sort keys %{$fields} ) {
        $val .= q{        "} . quotemeta($field) . q[" => {] . "\n";

        $val .= join ",\n", map {
                  q{            "}
                . quotemeta($_)
                . q{" => "}
                . quotemeta( $fields->{$field}{$_} ) . q{"}
            }
            sort keys %{ $fields->{$field} };

        $val .= ",\n";
        $val .= q[        },] . "\n";
    }

    $val .= q[    }];

    print {$fh} <<"EOF";
{
    my \$field_names = $val;
    sub _field_names { return \$field_names }
}
EOF
}

sub write_pm_footer {
    my $fh   = shift;
    my $ldml = shift;

    print {$fh} <<'EOF';
1;

__END__

EOF
}

sub generate_catalog {
    my @ldml = @_;

    print "\nGenerating catalog\n" if $opts{verbose};

    my $file = file(qw( lib DateTime Locale Catalog.pm ));

    open my $fh, '>:utf8', $file
        or die "Cannot write to $file: $!";

    generate_catalog_code( $fh, \@ldml );
    generate_catalog_pod( $fh, \@ldml );
}

sub generate_catalog_code {
    my $fh   = shift;
    my $ldml = shift;

    my $cldr_version = q{"} . quotemeta( $opts{version} ) . q{"};

    print {$fh} <<"EOF";
###########################################################################
#
# This file is auto-generated by the Perl DateTime Suite time locale
# generator ($VERSION).  This code generator comes with the
# DateTime::Locale distribution in the tools/ directory, and is called
# $ScriptName.
#
# This file as generated from the CLDR XML locale data.  See the
# LICENSE.cldr file included in this distribution for license details.
#
# Do not edit this file directly.
#
###########################################################################

package DateTime::Locale::Catalog;

use strict;
use warnings;
use utf8;

sub CLDRVersion { return $cldr_version }

my \@Locales;
sub Locales { return \@Locales }

my \%Aliases;
sub Aliases { return \%Aliases }

EOF

    print {$fh} '@Locales = (', "\n";

    for my $l ( @{$ldml} ) {
        print {$fh} catalog_data_for_locale($l);
    }

    print {$fh} q{);};
    print {$fh} "\n\n";

    print {$fh} catalog_data_for_aliases($ldml);

    print {$fh} <<'EOF';

1;

__END__

EOF
}

sub catalog_data_for_locale {
    my $ldml = shift;

    my $data = qq[    {\n];

    foreach my $k (
        qw( id
        en_language en_script en_territory en_variant
        native_language native_script native_territory native_variant
        )
        ) {
        my $val = $ldml->$k();
        next unless defined $val;

        $data .= sprintf( q{      %-16s => "}, $k );
        $data .= quotemeta($val);
        $data .= q{",} . "\n";
    }

    $data .= qq[    },\n];

    return $data;
}

sub catalog_data_for_aliases {
    my $ldml = shift;

    my %aliases = valid_aliases($ldml);

    my $code = '%Aliases = (' . "\n";

    for my $id ( sort keys %aliases ) {
        $code .= qq{    $id => "} . quotemeta( $aliases{$id} ) . qq{",\n};
    }

    $code .= ");\n";

    return $code;
}

sub generate_catalog_pod {
    my $fh   = shift;
    my $ldml = shift;

    my $locales_in_pod = '';

    for my $ldml ( @{$ldml} ) {
        my @pieces = join ' ',
            grep {defined}
            map  { $ldml->$_() } qw( en_language en_territory en_variant );

        my $script = $ldml->en_script();
        push @pieces, "($script)" if defined $script;

        $locales_in_pod
            .= sprintf( " %-18s  %s\n", $ldml->id(), join ' ', @pieces );
    }

    my %aliases = valid_aliases($ldml);

    my $aliases_in_pod = '';
    foreach my $id ( sort keys %aliases ) {
        $aliases_in_pod .= sprintf( " %-18s  %s\n", $id, $aliases{$id} );
    }

    print {$fh} <<"EOF";
=head1 NAME

DateTime::Locale::Catalog - Provides a list of all valid locale names

=head1 SYNOPSIS

See DateTime::Locale for usage details.

=head1 DESCRIPTION

This module contains a list of all known locales.

=head1 LOCALES

Any method taking locale id or name arguments should use one of the
values listed below. Ids and names are case sensitive. The id starts
with the ISO639-1 language code, and may also include information
identifying any or all of territory, script, or variant.

Always select the closest matching locale - for example, French
Canadians would choose fr_CA over fr - and B<always> use locale ids in
preference to names; locale ids offer greater compatibility when using
localized third party modules.

The available locales are:

 Locale id           Locale name
 ==================================================
$locales_in_pod

There are also many aliases available, mostly for three-letter
(ISO639-2) language codes, these are:

 Locale id           Is an alias for
 ==================================================
$aliases_in_pod

=head1 SUPPORT

See L<DateTime::Locale>.

=head1 AUTHOR

Dave Rolsky <autarch\@urth.org>

=head1 COPYRIGHT

Copyright (c) 2008 David Rolsky. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

This module was generated from data provided by the CLDR project, see
the LICENSE.cldr in this distribution for details on the CLDR data's
license.

=cut
EOF
}

{
    my %aliases;

    my %explicit = (
        'C'     => 'en_US_POSIX',
        'POSIX' => 'en_US_POSIX',

        # Apparently the Hebrew locale code was changed from iw to he at one
        # point.
        'iw_IL' => 'he_IL',
    );

    sub valid_aliases {
        return %aliases if keys %aliases;

        my $ldml = shift;

        my %ids = map { $_->id() => 1 } @{$ldml};

        for my $ldml ( @{$ldml} ) {
            if ( $ldml->alias_to() ) {
                $aliases{ $ldml->id() } = $ldml->alias_to();
                next;
            }

            my $three = iso639_2_to_3( $ldml->language() );

            next unless defined $three;

            my $three_id = (
                join '_',
                grep {defined}
                    $three, $ldml->territory(), $ldml->script(),
                $ldml->variant()
            );

            next if $ids{$three_id};

            $aliases{$three_id} = $ldml->id();
        }

        %aliases = ( %aliases, %explicit );

        return %aliases;
    }
}

{
    my %iso639_map;

    sub iso639_2_to_3 {
        my $two = shift;

        _build_iso639_map() unless keys %iso639_map;

        return $iso639_map{$two};
    }

    sub _build_iso639_map {
        my $iso639 = get('http://www.loc.gov/standards/iso639-2/ISO-639-2_utf-8.txt');
        # Trim BOM
        $iso639 = substr( $iso639, 1 );

        for my $line ( split /\n/, $iso639 ) {
            next unless $line =~ /\S/;
            next if $line =~ /^\#/;

            my ( $three, $two ) = ( split /\|/, $line )[0, 2];

            next unless defined $two;

            $iso639_map{$two} = $three;
        }
    }
}

sub generate_pm_file_pod {
    my $ldml = shift;

    my $id = $ldml->id();
    print "Generating POD for $id\n" if $opts{verbose};

    my $pm_file = file( qw( lib DateTime Locale ), $id . q{.pm} );

    require DateTime::Locale;

    my $locale = DateTime::Locale->load( $id );

    open my $fh, '>>:utf8', $pm_file
        or die "Cannot append to $pm_file: $!";

    write_pm_file_pod_header( $fh, $locale, $ldml );

    print {$fh} pod_for_days($locale);
    print {$fh} pod_for_months($locale);
    print {$fh} pod_for_quarters($locale);
    print {$fh} pod_for_eras($locale);
    print {$fh} pod_for_formats($locale);
    print {$fh} pod_for_field_names($locale);
    print {$fh} pod_for_relative_field_names($locale);
    print {$fh} pod_for_misc($locale);
    print {$fh} pod_footer($locale);
}

sub write_pm_file_pod_header {
    my $fh     = shift;
    my $locale = shift;
    my $ldml   = shift;

    my $class = ref $locale;
    my $id    = $locale->id();
    my $name  = $locale->name();

    print {$fh} <<"EOF";

=pod

=encoding utf8

=head1 NAME

$class

=head1 SYNOPSIS

  use DateTime;

  my \$dt = DateTime->now( locale => '$id' );
  print \$dt->month_name();

=head1 DESCRIPTION

This is the DateTime locale package for $name.

=head1 DATA

EOF

    if ( $id ne 'root' ) {
        print {$fh} 'This locale may include data from the following other locales: ';
        print {$fh} join ' - ', $ldml->parent_ids();
    }

    print {$fh} "It contains the following data.\n\n";
}

sub pod_for_days {
    my $locale = shift;

    return pod_for_variations( $locale, 'day' );
}

sub pod_for_months {
    my $locale = shift;

    return pod_for_variations( $locale, 'month' );
}

sub pod_for_quarters {
    my $locale = shift;

    return pod_for_variations( $locale, 'quarter' );
}

sub pod_for_eras {
    my $locale = shift;

    return pod_for_variations( $locale, 'era' );
}

sub pod_for_variations {
    my $locale = shift;
    my $thing  = shift;

    my $pod = '';

    my $pl = PL_N($thing);
    $pod .= "=head2 \u$pl\n\n";

    my @forms = $thing eq 'era' ? ('') : ( 'format', 'stand_alone' );

    for my $form (@forms) {
        for my $size (qw( wide abbreviated narrow )) {
            my $meth
                = $form
                ? $thing . q{_} . $form . q{_} . $size
                : $thing . q{_} . $size;

            next unless $locale->can($meth);

            my $head = ucfirst $size;

            if ($form) {
                ( my $f = $form ) =~ s/_/-/;
                $head .= " ($f)";
            }

            $pod .= "=head3 $head\n\n";

            for my $val ( @{ $locale->$meth() } ) {
                $pod .= "  $val\n";
            }

            $pod .= "\n";
        }
    }

    return $pod;
}

sub pod_for_formats {
    my $locale = shift;

    unless ( DateTime->can('new') ) {
        eval "use DateTime 0.43";
        die $@ if $@;
    }

    my @dts = (
        DateTime->new(
            year      => 2008,
            month     => 2,
            day       => 5,
            hour      => 18,
            minute    => 30,
            second    => 30,
            locale    => $locale,
            time_zone => 'UTC',
        ),
        DateTime->new(
            year       => 1995,
            month      => 12,
            day        => 22,
            hour       => 9,
            minute     => 5,
            second     => 2,
            nanosecond => 505_196,
            locale     => $locale,
            time_zone  => 'UTC',
        ),
        DateTime->new(
            year      => -10,
            month     => 9,
            day       => 15,
            hour      => 4,
            minute    => 44,
            second    => 23,
            locale    => $locale,
            time_zone => 'UTC',
        ),
    );

    return pod_for_standard_formats( $locale, \@dts )
        . pod_for_available_formats( $locale, \@dts );
}

sub pod_for_standard_formats {
    my $locale = shift;
    my $dts    = shift;

    my $pod = '';

    for my $type (qw( date time datetime )) {
        $pod .= "=head2 \u$type Formats\n\n";

        for my $length (qw( full long medium short default )) {
            $pod .= "=head3 \u$length\n\n";

            my $meth = $type . q{_} . 'format' . q{_} . $length;

            for my $dt ( @{$dts} ) {
                $pod .= sprintf(
                    '  %20s = %s',
                    $dt->iso8601(),
                    $dt->format_cldr( $locale->$meth() ),
                );
                $pod .= "\n";
            }

            $pod .= "\n";
        }
    }

    return $pod;
}

sub pod_for_available_formats {
    my $locale = shift;
    my $dts    = shift;

    my $pod = "=head2 Available Formats\n\n";

    for my $format ( sort { lc $a cmp lc $b or $a cmp $b }
        $locale->available_formats() ) {

        my $cldr = $locale->format_for($format);

        $pod .= "=head3 $format ($cldr)\n\n";

        for my $dt ( @{$dts} ) {
            $pod .= sprintf(
                '  %20s = %s',
                $dt->iso8601(),
                $dt->format_cldr($cldr),
            );

            $pod .= "\n";
        }

        $pod .= "\n";
    }

    return $pod;
}

{
    my @fields = qw( era year month day weekday dayperiod hour minute zone );

    sub pod_for_field_names {
        my $locale = shift;

        my $pod = "=head2 Field Names\n\n";

        $pod .= "=over 4\n\n";

        for my $field (@fields) {
            $pod .= "=item * $field = ";

            $pod .= $locale->field_name($field) . "\n\n";
        }

        $pod .= "=back\n\n";

        return $pod;
    }

    sub pod_for_relative_field_names {
        my $locale = shift;

        my $pod = q{};

        for my $field (@fields) {
            my %rel_names;

            for my $rel ( -3 .. 3 ) {
                my $rel_name = $locale->relative_field_name( $field, $rel );
                next unless defined $rel_name;

                $rel_names{$rel} = $rel_name;
            }

            next unless keys %rel_names;

            $pod .= "=head3 $field\n\n";

            $pod .= "=over 4\n\n";

            for my $rel ( sort { $a <=> $b } keys %rel_names ) {
                $pod .= "=item * $rel = $rel_names{$rel}\n\n";
            }

            $pod .= "=back\n\n";

            $pod .= "\n";
        }

        return unless length $pod;

        $pod = "=head2 Relative Field Names\n\n" . $pod;

        return $pod;
    }
}

sub pod_for_misc {
    my $locale = shift;

    my $pod = "=head2 Miscellaneous\n\n";

    $pod .= "=head3 Prefers 24 hour time?\n\n";

    $pod .= $locale->prefers_24_hour_time() ? 'Yes' : 'No';
    $pod .= "\n\n";

    $pod .= "=head3 Local first day of the week\n\n";

    $pod .= $locale->day_format_wide()->[ $locale->first_day_of_week() - 1 ];
    $pod .= "\n\n";

    return $pod;
}

sub pod_footer {
    return <<'EOF';

=head1 SUPPORT

See L<DateTime::Locale>.

=head1 AUTHOR

Dave Rolsky <autarch@urth.org>

=head1 COPYRIGHT

Copyright (c) 2008 David Rolsky. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

This module was generated from data provided by the CLDR project, see
the LICENSE.cldr in this distribution for details on the CLDR data's
license.

=cut
EOF
}

sub write_to_manifest {
    return if $opts{file};

    my $fh = _manifest_handle();

    print {$fh} $_, "\n" for @_;
}

{
    my $fh;

    sub _manifest_handle {
        return $fh if defined $fh;

        copy( 'MANIFEST.base', 'MANIFEST' );
        open $fh, '>>', 'MANIFEST' or die "Cannot write to MANIFEST: $!";

        return $fh;
    }
}

main();
